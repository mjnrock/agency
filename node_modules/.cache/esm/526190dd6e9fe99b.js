let EventEmitter,uuidv4;_6e9‍.x([["default",()=>Validator]]);_6e9‍.w("events",[["default",["EventEmitter"],function(v){EventEmitter=v}]]);_6e9‍.w("uuid",[["v4",["uuidv4"],function(v){uuidv4=v}]]);


               class Validator extends EventEmitter {
    static GroupLogicType = {
        CONJUNCT: 2 << 0,
        NEGATION: 2 << 1,
    };

    constructor(...evaluators) {
        super();

        this._id = uuidv4();
        this._evaluators = evaluators;
        this._mask = 0;

        if(typeof evaluators[ 0 ] === "number") {
            this._mask = evaluators[ 0 ];
            this._evaluators = evaluators.slice(1);
        }
    }

    add(...fns) {
        this._evaluators = [
            ...this._evaluators,
            ...fns,
        ];

        return this;
    }
    remove(...fns) {
        for(let fn of fns) {
            this._evaluators = this._evaluators.filter(e => e !== fn);
        }

        return this;
    }

    run(...args) {
        const results = [];
        for(let fn of this._evaluators) {
            if(typeof fn === "function") {
                results.push(fn(...args));
            } else if(fn instanceof Validator) {
                results.push(fn.run(...args));
            } else {
                throw new Error("@evaluator must be a function");
            }
        }

        let result;
        if((this._mask & Validator.GroupLogicType.CONJUNCT) === Validator.GroupLogicType.CONJUNCT) {
            result = results.every(input => input === true);
        } else {
            result = results.some(input => input === true);
        }

        if((this._mask & Validator.GroupLogicType.NEGATION) === Validator.GroupLogicType.NEGATION) {
            result = !result;
        }

        if(result === true) {
            this.emit("activate");
        }

        return result;
    }
};